## Lecture 01: Tuesday, January 28 2025

### Announcements

0. Initial submission for the setup assignment is due today, get going on peer review due tomorrow, and final submission due Thursday

0. We encourage you to turn your camera and on and use the microphone to participate

### Review

Welcome to the [Matrix](/matrix.md). If you have not joined yet please do so ASAP. This is not optional.

Read through the [FAQ](/faq.md). This and the [homepage](/index.md) is what we covered in [L00](/lectures/L00.md).

### Lecture overview

0. Why [setup](/setup.md)?

0. Back to basics: `noconfig`

0. Demo: we have the asm program (show it), introduce the noconfig kernel, try to run asm with noconfig, oops doesn't work, walk through turning on different configs to get the program running, intrpoduce gdb attachment, and active serial output os we can see asm execution.

### Notes

Build up from the barebones kernel

#### The Barebones Kernel

The smallest config possible?

```
$ cat no.config
# Allow turning off even more stuff
CONFIG_EXPERT=y
CONFIG_NONPORTABLE=y

# Save time by skipping compressing the kernel, we only want an uncompressed image for qemu
CONFIG_KERNEL_UNCOMPRESSED=y

# Build a kernel to run in m-mode so we can avoid needing a bios
CONFIG_RISCV_M_MODE=y
```

Build the config

```
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make KCONFIG_ALLCONFIG=no.config allnoconfig
```

Breakdown:

* `ARCH=riscv`: specify non-host architecture to kernel buildsystem ([Kbuild](https://docs.kernel.org/kbuild/kbuild.html))

* `CROSS_COMPILE=riscv64-linux-gnu-`: specify prefix for `gcc` command in order to invoke cross-compiler

* `make`: invoke the make program (the real command)

* `KCONFIG_ALLCONFIG=no.config`: generate a full config using this file as a starting point

* `allnoconfig`: the makefile target to generate a config with everything set to no unless specified in `no.config`

Cross compile the kernel

```
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make -j $(nproc)
```

Breakdown:

* `ARCH=riscv`: specify non-host architecture to kernel buildsystem ([Kbuild](https://docs.kernel.org/kbuild/kbuild.html))

* `CROSS_COMPILE=riscv64-linux-gnu-`: specify prefix for `gcc` command in order to invoke cross-compiler

* `make`: invoke the make program (the real command)

* `-j $(nproc)`: perform a multi-threaded build, creating as many threads as there are visible CPU cores on the system

* No target is specified, therefore `make` falls back to the default target, i.e. build the kernel (and generate `arch/riscv/boot/Image`)

Launch the emulator

```
qemu-system-riscv64 -machine virt -bios none -nographic -no-reboot -net none -kernel arch/riscv/boot/Image
```

Breakdown:

* `qemu-system-riscv64`: invoke the RISC-V 64-bit emulator

* `-machine virt`: specify a hardware configuration suitable for general purpose virtualization

* `-bios none`: disable bios loading (and later directly specify a kernel binary image)

* `-nographic`: disable graphical output

* `-no-reboot`: don't automatically reboot the OS exits or errors

* `-net none`: disable networking

* `-kernel arch/riscv/boot/Image`: assuming we invoke this within the kernel repo post-build, pass the resulting binary to QEMU

#### GDB

How do we see what's going on?

```
$ cat linux/gdbinit
# disable confirmation prompts to save time (for kill/quit)
set confirm off
# automatically disaassemble the next line when stepping through code
set disassemble-next-line auto
# set arch to RISC-V (64-bit variant)
set architecture riscv:rv64
# load the symbol table from the vmlinux file
symbol-file vmlinux
# load the vmlinux file for debugging
file vmlinux
# connect to the remote host at localhost on port 1234
target remote localhost:1234
```


```
qemu-system-riscv64 -machine virt -bios none -nographic -no-reboot -net none -kernel arch/riscv/boot/Image -S -s
```

Breakdown of new arguments:

* `-s`: enable debug socket on port 1234
* `-S`: freeze the CPU and wait for continue from debugger before running any instructions


In a separate shell session

```
gdb -x gdbinit
... c to continue
... Ctrl+C to send interrupt
... bt to backtrace
#0  0x000000008012559c in udelay ()
#1  0x000000008000133c in panic ()
#2  0x0000000080127184 in kernel_init ()
#3  0x000000008012b4d8 in ret_from_fork ()
... kill to stop the machine
(back in the other terminal)
qemu-system-riscv64: QEMU: Terminated via GDBstub
```


How do we make this more detailed? Where are the line numbers?


Enable debuginfo in config
```
# Include debug symbols
CONFIG_DEBUG_INFO_DWARF4=y
```

#### Printk

Why did the kernel panic? ðŸ¤”


Enable some more options in the config

```
$ cat noise.config
... (trimmed)
# enable kernel printing output
CONFIG_PRINTK=y

# enable serial subsystem
CONFIG_TTY=y

# Add driver for serial device for machine
CONFIG_SERIAL_8250=y

# Allow using that serial port for console
CONFIG_SERIAL_8250_CONSOLE=y
```

Rebuild config & kernel, then relaunch the emulator
```
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make KCONFIG_ALLCONFIG=noise.config allnoconfig
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make -j $(nproc)
qemu-system-riscv64 -machine virt -bios none -nographic -no-reboot -net none -kernel arch/riscv/boot/Image
```

Silence... why?

How does the kernel know to use this device?

(question for audience)


Another QEMU argument: `-append`

What do you think this does?

kernel command line arguments:

```
earlycon=uart8250,mmio,0x10000000 console=uart8250,mmio,0x10000000
```

Breakdown:

* `{earlycon,console}=`: specify information needed to print to a console early in the boot process and then during normal execution

* `uart8250`: Use the 8250 UART driver that we enabled in the config

* `mmio`: The kernel should communicate with the driver using memory-mapped I/O rather than I/O ports

* `0x10000000`: Base address for the UART device in physical memory

[(console= vs earlycon= and friends)](https://docs.kernel.org/admin-guide/kernel-parameters.html)



Let's run it!

```
$ qemu-system-riscv64 -machine virt -bios none -nographic -no-reboot -net none -kernel arch/riscv/boot/Image -append 'earlycon=uart8250,mmio,0x10000000 console=uart8250,mmio,0x10000000'
Linux version 6.13.0 (joel@fedora) (riscv64-linux-gnu-gcc (GCC) 14.1.1 20240507 (Red Hat Cross 14.1.1-1), GNU ld version 2.41-1.fc40) #7 Fri Jan 24 12:08:42 EST 2025
random: crng init done
Machine model: riscv-virtio,qemu
earlycon: uart8250 at MMIO 0x0000000010000000 (options '')
printk: legacy bootconsole [uart8250] enabled
OF: reserved mem: Reserved memory: No reserved-memory node in the DT
Zone ranges:
  DMA32    [mem 0x0000000080000000-0x0000000087ffffff]
  Normal   empty
Movable zone start for each node
Early memory node ranges
  node   0: [mem 0x0000000080000000-0x0000000087ffffff]
Initmem setup node 0 [mem 0x0000000080000000-0x0000000087ffffff]
riscv: base ISA extensions
riscv: ELF capabilities
Ticket spinlock: enabled
Kernel command line: console=uart8250,mmio,0x10000000
printk: log buffer data + meta data: 131072 + 458752 = 589824 bytes
Dentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
Inode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
Built 1 zonelists, mobility grouping on.  Total pages: 32768
mem auto-init: stack:all(zero), heap alloc:off, heap free:off
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
riscv-intc: 64 local interrupts mapped
clint: clint@2000000: timer running at 10000000 Hz
clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x24e6a1710, max_idle_ns: 440795202120 ns
sched_clock: 64 bits at 10MHz, resolution 100ns, wraps every 4398046511100ns
Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj=40000)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
Memory: 126060K/131072K available (1351K kernel code, 540K rwdata, 168K rodata, 124K init, 171K bss, 4660K reserved, 0K cma-reserved)
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
cpu0: Ratio of byte access time to unaligned word access is 6.88, unaligned accesses are fast
clocksource: Switched to clocksource clint_clocksource
workingset: timestamp_bits=62 max_order=15 bucket_order=0
riscv-plic: plic@c000000: mapped 95 interrupts with 1 handlers for 2 contexts.
Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
clk: Disabling unused clocks
Warning: unable to open an initial console.
Freeing unused kernel image (initmem) memory: 124K
This architecture does not have kernel memory protection.
Run /sbin/init as init process
Run /etc/init as init process
Run /bin/init as init process
Run /bin/sh as init process
Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.
---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---
```

What is the [admin guide](https://docs.kernel.org/admin-guide/init.html)?

#### The Device Tree

Can we do this automatically?

```
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make  menuconfig
  â”‚     -> Device Drivers                                                                                                                                           â”‚
  â”‚       -> Character devices                                                                                                                                      â”‚
  â”‚         -> Enable TTY (TTY [=y])                                                                                                                                â”‚
  â”‚           -> Serial drivers                                                                                                                                     â”‚
  â”‚ (1)         -> Devicetree based probing for 8250 ports (SERIAL_OF_PLATFORM [=n])
... press y to enable
# can we do this faster?
... ('/' to search: CONFIG_SERIAL_OF_PLATFORM, press 1)
# note that we see the above path, which is also manual navigation instructions
ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- make -j $(nproc)
# now we can drop the "-append..."
qemu-system-riscv64 -machine virt -bios none -nographic -no-reboot -net none -kernel arch/riscv/boot/Image
..... (panic)
```

Without menuconfig, you can use [this baseline config](/demo_materials/dt_noise.config) and pass it as above.

#### debugging

Why are we panic()ing?

Let's figure it out

0. brain dead

give up and change majors

0. small brain

Grep for text "no working init found"

0. small-medium brain

`git grep`

0. medium brain

Look for the function in the source

Look at init/main.c:1528

0. Big Brain

Use System.map

`addr2line 0x000000008014ea50 -e vmlinux`

0. Galaxy brain

Get into GDB

Add the `-s -S`

```
c
...Ctrl+c
disas
list
layout asm
layout src
layout next
tui focus next
tui disable
```



#### init

what is `try_to_run_init_process("/etc/init")`??

break there
layout src
step into functions
next over functions
(optimized kernel so some stuff missed)

kernel_execve


struct filename

alloc_bprm

do_open_execat

do_filep_open
